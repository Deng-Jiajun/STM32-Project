#include "sys.h"
#include "oledfont.h"

/* 只用于模块内部调用的函数 👇 */

void __OLED_Send_Command(uint8_t cmd);
void __OLED_Send_Data(uint8_t data);
void __OLED_Set_Pos(uint8_t x, uint8_t y);
void __OLED_ShowChar(uint8_t x, uint8_t y, char ch, uint8_t size);
void __OLED_ShowChineseChar(uint8_t x, uint8_t y, uint8_t index, uint8_t size);
void __OLED_ShowStr(uint8_t x, uint8_t y, char *str, uint8_t size);
void __OLED_ShowNum(uint8_t x, uint8_t y, int num, uint8_t size);
void __OLED_Int2Str(int num, char *str);

/**
 * @brief 关于坐标系
 * x，从左到右（从 0 到 127，单位为 SEG），y，从上到下（从 0 到 7，单位为 PAGE）
 * x: 0----->127
 * y: 0
 *    |
 *    |
 *    |
 *    v
 *    7
 */

/**
 * @brief OLED 初始化
 *
 */
void OLED_Init(void)
{
    /* IIC 初始化 */
    IIC_Init();

    /* 初始化前延时一段时间 */
    delay_ms(800);

    /* 关闭显示（开始配置/初始化 OLED） */
    __OLED_Send_Command(0xAE); // Set Display ON/OFF
    /** 👆
     * 1 0 1 0 1 1 1 X0
     * AEh, X[0]=0b:Display OFF (sleep mode) (RESET)
     * AFh, X[0]=1b:Display ON in normal mode
     */

    /* 设置时钟分频系数/震荡频率 */
    __OLED_Send_Command(0xD5); // Set Display Clock Divide Ratio/Oscillator Frequency
    __OLED_Send_Command(0x80); // 默认值 0x80
    /** 👆
     * [3:0] : Define the divide ratio (D) of the display clocks (DCLK):
     * Divide ratio= [3:0] + 1, RESET is 0000b (divide ratio = 1)
     *
     * [7:4] :Set the Oscillator Frequency, FOSC.
     * Oscillator Frequency increases with the value of [7:4] and vice versa.
     * RESET is 1000b Range:0000b~1111b
     * Frequency increases as setting value increases.
     */

    // 这个和 COM 好像有关
    /* 设置驱动路数 */
    __OLED_Send_Command(0xA8); // Set Multiplex Ratio
    __OLED_Send_Command(0x3F); // 默认值 0x3F(63, 1/64 duty)
    /** 👆
     * N=[5:0] : from 16MUX to 64MUX, RESET= 111111b (i.e. 63d, 64MUX)
     *           from 0 to 14 are invalid entry.
     */

    /* 设置显示偏移 位移映射 RAM 计数器 */
    __OLED_Send_Command(0xD3); // Set Display Offset
    __OLED_Send_Command(0x00); // 默认值 0x00
    /**👆
     * Set vertical shift by COM from 0d~63d The value is reset to 00h after RESET.
     */

    /* 设置显示开始行（行数：[5:0]）映射 RAM 显示起始行(0x00~0x3F) */
    __OLED_Send_Command(0x40); // Set Display Start Line，默认值 0x40 （01开头）
    /** 👆
     * Set display RAM display start line register from 0-63 using X5X3X2X1X0.
     * Display start line register is reset to 000000b during RESET.
     */

    /* 设置电荷泵 */
    __OLED_Send_Command(0x8D); // Charge Pump Setting
    __OLED_Send_Command(0x14); // 开启电荷泵（bit2=1）
    /** 👆
     * A[7:0]：* * 0 1 0 A2 0 0
     * A[2] = 0b, Disable charge pump(RESET)
     * A[2] = 1b, Enable charge pump during display on
     *
     * Note
     * The Charge Pump must be enabled by the following command:
     * 8Dh ; Charge Pump Setting
     * 14h ; Enable Charge Pump
     * AFh; Display ON
     */

    /* ----- 纵向：COM0 ~ COM63； 横向：SEG0 ~ SEG127 ----- */

    /* SEG 重映射（水平翻转，列重映射） */
    __OLED_Send_Command(0xA1); // Set Segment Re-map
    /** 👆
     * A0h, X[0]=0b: column address 0 is mapped to SEG0 (RESET)
     * A1h, X[0]=1b: column address 127 is mapped to SEG0
     */

    /* COM 扫描方向重映射（垂直翻转，行重映射） */
    __OLED_Send_Command(0xC8); // Set COM Output Scan Direction
    /** 👆
     * 1 1 0 0 X3 0 0 0
     * C0h, X[3]=0b: normal mode (RESET) Scan from COM0 to COM[N –1]
     * C8h, X[3]=1b: remapped mode. Scan from COM[N-1] to COM0
     * Where N is the Multiplex ratio.
     */

    /* 设置 COM 硬件引脚配置 */
    __OLED_Send_Command(0xDA); // Set COM Pins Hardware Configuration
    __OLED_Send_Command(0x12); // 默认值 0x12（禁用左右重映射）
    /** 👆
     * 0 0 A5 A4 0 0 1 0
     * A[4]=0b, Sequential COM pin configuration
     * A[4]=1b(RESET), Alternative COM pin configuration
     * A[5]=0b(RESET), Disable COM Left/Right remap
     * A[5]=1b, Enable COM Left/Right remap
     */

    /* 设置对比度 */
    __OLED_Send_Command(0x81); // Set Contrast Control
    __OLED_Send_Command(0xCF); // 「VCC Generated by Internal DC/DC Circuit」
    /** 👆
     * to select 1 out of 256 contrast steps.
     * Contrast increases as the value increases. (RESET = 7Fh )
     */

    /* 设置预充电周期 */
    __OLED_Send_Command(0xD9); // Set Pre-charge Period
    __OLED_Send_Command(0xF1); // 「VCC Generated by Internal DC/DC Circuit」
    /** 👆
     * A[3:0] : Phase 1 period of up to 15 DCLK
     *          clocks 0 is invalid entry (RESET=2h)
     * A[7:4] : Phase 2 period of up to 15 DCLK
     *          clocks 0 is invalid entry (RESET=2h )
     */

    /* 设置 VCOMH 电压倍率 */
    __OLED_Send_Command(0xDB); // Set VCOMH Deselect Level
    __OLED_Send_Command(0x30); // 0.83 x VCC
    /** 👆
     * adjusts the VCOMH regulator output.
     * 0 A6 A5 A4 0 0 0 0
     * [6:4] : VCOMH Deselect Level
     * 000: 0.65 x VCC
     * 001: 0.77 x VCC (RESET)
     * 011: 0.83 x VCC
     */

    /* 设置全局显示 */
    __OLED_Send_Command(0xA4); // Set Entire Display On/Off（默认值 0xA4）
    /** 👆
     * 1 0 1 0 0 1 0 X0
     * A4h, X0=0b: Resume to RAM content display (RESET)
     *             Output follows RAM content
     * A5h, X0=1b: Entire display ON
     *             Output ignores RAM content
     */

    /* 正常显示模式 */
    __OLED_Send_Command(0xA6); // Set Normal/Inverse Display（默认值 0xA6）
    /** 👆
     * 1 0 1 0 0 1 1 X0
     * A6h, X[0]=0b: Normal display (RESET)
     *      0 in RAM: OFF in display panel
     *      1 in RAM: ON in display panel
     * A7h, X[0]=1b: Inverse display
     *      0 in RAM: ON in display panel
     *      1 in RAM: OFF in display panel
     */

    /* 设置寻址模式（页寻址） */
    __OLED_Send_Command(0x20); // Set Memory Addressing Mode
    __OLED_Send_Command(0x02); // 页寻址模式（默认）
    /** 👆
     * * * * * * * A1 A0
     * A[1:0] = 00b, Horizontal Addressing Mode
     * A[1:0] = 01b, Vertical Addressing Mode
     * A[1:0] = 10b, Page Addressing Mode (RESET)
     * A[1:0] = 11b, Invalid
     */

    /**
     * @note 基本可以确定，针对页寻址模式起始地址的这部分配置没有实际作用，因为
     * 每次显示内容前，都会重新设置起始地址，但是因为写了具体描述，所以予以保留
     */

    /* 设置页寻址模式的页面起始地址 */
    __OLED_Send_Command(0xB0); // Set Page Start Address for Page Addressing Mode
    /** 👆
     * 1 0 1 1 0 X2 X1 X0    （B0~B7）
     * Set GDDRAM Page Start Address (PAGE0~PAGE7) for Page Addressing Mode using X[2:0].
     */

    /* 设置页寻址模式的低列起始地址（默认值 0x00） */
    __OLED_Send_Command(0x00); // Set Lower Column Start Address for Page Addressing Mode
    /** 👆
     * 0 0 0 0 X3 X2 X1 X0    （00~0F）
     * Set the lower nibble of the column start address register for Page Addressing Mode using X[3:0] as data bits.
     * The initial display line register is reset to 0000b after RESET.
     */

    /* 设置页寻址模式的高列起始地址（默认值 0x10） */
    __OLED_Send_Command(0x10); // Set Higher Column Start Address for Page Addressing Mode
    /** 👆
     * 0 0 0 1 X3 X2 X1 X0    （10~1F）
     * Set the higher nibble of the column start address register for Page Addressing Mode using X[3:0] as data bits.
     * The initial display line register is reset to 0000b after RESET.
     */

    /* 清屏 */
    OLED_Clear();

    /* 开启显示（结束配置/初始化 OLED） */
    __OLED_Send_Command(0xAF); // Set Display ON/OFF
    /** 👆
     * 1 0 1 0 1 1 1 X0
     * AEh, X[0]=0b:Display OFF (sleep mode) (RESET)
     * AFh, X[0]=1b:Display ON in normal mode
     */
}

/**
 * @brief 向 OLED 发送命令
 *
 * @param cmd 发送的命令字节
 */
void __OLED_Send_Command(uint8_t cmd)
{
    /* 起始信号 */
    IIC_Start();

    /**
     * @brief 发送从机地址（写模式）
     *
     * 0 1 1 1 1 0 SA0 R/W#
     * SA0 默认是 0（通过 D/C 引脚改变）
     * R/W# = 0 是写模式
     * R/W# = 1 是读模式
     */
    IIC_Send_Data(OLED_Slave_Address_Write); // 也可写成 IIC_Send_Data(0x3C<<1);

    /**
     * @brief 跟在从机地址后面的一个字节
     *
     * Co D/C# 0 0 0 0 0 0
     *
     * Co=0，后面传输的都是数据字节

     * D/C#=0，下一个数据字节被看作命令
     * D/C#=1，下一个数据字节被看作数据，将会存在 GDDRAM 中，GDDRAM 列地址指针将会在每次数据写之后自动加 1
     */
    /**
     * If the Co bit is set as logic “0”, the transmission of the following information will contain data bytes only.
     *
     * The D/C# bit determines the next data byte is acted as a command or a data.
     * - If the D/C# bit is set to logic “0”, it defines the following data byte as a command.
     * - If the D/C# bit is set to logic “1”, it defines the following data byte as a data which will be stored at the GDDRAM.
     *   The GDDRAM column address pointer will be increased by one automatically after each data write.
     */
    IIC_Send_Data(0x00); // 下一个数据字节被看作命令

    /* 发送命令 */
    IIC_Send_Data(cmd);

    /* 停止信号 */
    IIC_Stop();
}

/**
 * @brief 向 OLED 发送数据
 *
 * @param data 发送的数据字节
 */
void __OLED_Send_Data(uint8_t data)
{ /* 起始信号 */
    IIC_Start();

    /**
     * @brief 发送从机地址（写模式）
     *
     * 0 1 1 1 1 0 SA0 R/W#
     * SA0 默认是 0（通过 D/C 引脚改变）
     * R/W# = 0 是写模式
     * R/W# = 1 是读模式
     */
    IIC_Send_Data(OLED_Slave_Address_Write); // 也可写成 IIC_Send_Data(0x3C<<1);

    /**
     * @brief 跟在从机地址后面的一个字节
     *
     * Co D/C# 0 0 0 0 0 0
     *
     * Co=0，后面传输的都是数据字节

     * D/C#=0，下一个数据字节被看作命令
     * D/C#=1，下一个数据字节被看作数据，将会存在 GDDRAM 中，GDDRAM 列地址指针将会在每次数据写之后自动加 1
     */
    /**
     * If the Co bit is set as logic “0”, the transmission of the following information will contain data bytes only.
     *
     * The D/C# bit determines the next data byte is acted as a command or a data.
     * - If the D/C# bit is set to logic “0”, it defines the following data byte as a command.
     * - If the D/C# bit is set to logic “1”, it defines the following data byte as a data which will be stored at the GDDRAM.
     *   The GDDRAM column address pointer will be increased by one automatically after each data write.
     */
    IIC_Send_Data(0x40); // 下一个数据字节被看作数据

    /* 发送数据 */
    IIC_Send_Data(data);
    /* 停止信号 */
    IIC_Stop();
}

/**
 * @brief OLED 清屏（熄屏）
 *
 */
void OLED_Clear(void)
{
    uint8_t i, j;
    for (i = 0; i < 8; i++)
    {
        __OLED_Send_Command(0xB0 + i); // 设置页起始地址（0 ~ 7）
        __OLED_Send_Command(0x00);     // 设置低列起始地址（默认值 0x00）
        __OLED_Send_Command(0x10);     // 设置高列起始地址（默认值 0x10）

        /* 8 个 页（PAGE） 的 128 列（SEG） 全部写 0 */
        for (j = 0; j < 128; j++)
            __OLED_Send_Data(0);
    }
}

/**
 * @brief OLED 全屏点亮
 *
 */
void OLED_On(void)
{
    uint8_t i, j;
    for (i = 0; i < 8; i++)
    {
        __OLED_Send_Command(0xB0 + i); // 设置页起始地址（0 ~ 7）
        __OLED_Send_Command(0x00);     // 设置低列起始地址（默认值 0x00）
        __OLED_Send_Command(0x10);     // 设置高列起始地址（默认值 0x10）

        /* 8 个 页（PAGE） 的 128 列（SEG） 全部写 1 */
        for (j = 0; j < 128; j++)
            __OLED_Send_Data(1);
    }
}

/**
 * @brief OLED 设置坐标（起始地址）
 *
 * @param x 横坐标，设置列（SEG）起始地址（SEG = x, x=0..127）
 * @param y 纵坐标，设置页（PAGE）起始地址（PAGE = y, y=0..7）
 */
void __OLED_Set_Pos(uint8_t x, uint8_t y)
{
    __OLED_Send_Command(0xB0 + y);
    __OLED_Send_Command(((x & 0xF0) >> 4) | 0x10); // 设置高列地址
    __OLED_Send_Command((x & 0x0F));               // 设置低列地址
}

/**
 * @brief OLED 显示字符
 *
 * @param x 横坐标，设置列（SEG）起始地址（SEG = x, x=0..127）
 * @param y 纵坐标，设置页（PAGE）起始地址（PAGE = y, y=0..7）
 * @param ch 要显示的字符
 * @param size 字体大小
 *
 * @note
 * - 理想情况下，一个字符占两个 PAGE，一个 PAGE 占 8 个 SEG
 *   字符字体大小 16（字高 16，字宽 8）
 * - 其他情况下，一个字符占一个 PAGE，一个 PAGE 占 6 个 SEG
 *   字符字体大小 8（字高 8，字宽 6）
 */
void __OLED_ShowChar(uint8_t x, uint8_t y, char ch, uint8_t size)
{
    uint8_t i = 0;
    uint8_t index = ch - ' '; // 得到偏移后的值

    /* 如果这一行写不下，就写到下一行（PAGE+2）的开头(SEG=0) */
    if (x > 127 - 8 + 1)
    {
        x = 0;
        y = y + 2;
    }

    /* 如果 size=16，则显示字符为字高=16，字宽=8 */
    if (size == 16)
    {
        __OLED_Set_Pos(x, y);
        for (i = 0; i < 8; i++)
            __OLED_Send_Data(F8X16[index * 16 + i]); // 上半部分
        __OLED_Set_Pos(x, y + 1);
        for (i = 0; i < 8; i++)
            __OLED_Send_Data(F8X16[index * 16 + i + 8]); // 下半部分
    }
    /* size!=16 时，显示字符为字高=8，字宽=6 */
    else
    {
        __OLED_Set_Pos(x, y);
        for (i = 0; i < 6; i++)
            __OLED_Send_Data(F6x8[index][i]);
    }
}

/**
 * @brief OLED 显示字符串
 *
 * @param x 横坐标，设置列（SEG）起始地址（SEG = x, x=0..127）
 * @param y 纵坐标，设置页（PAGE）起始地址（PAGE = y, y=0..7）
 * @param str 要显示的字符串
 * @param size 字体大小
 *
 * @note 理想情况下，一个字符占两个 PAGE，一个 PAGE 占 8 个 SEG
 *       字符字体大小 16（字高 16，字宽 8）
 * @see __OLED_ShowChar()
 */
void __OLED_ShowStr(uint8_t x, uint8_t y, char *str, uint8_t size)
{
    /* 调用 __OLED_ShowChar() 显示字符串中的字符 */
    while (*str != '\0')
    {
        __OLED_ShowChar(x, y, *str++, size);
        x += 8;
        /* 👆 虽然可能输出字高为 8 字宽为 6 的字符，但是所占的宽度依然是 8 */

        /* 如果这一行写不下，就写到下一行（PAGE+2）的开头(SEG=0) */
        if (x > 127 - 8 + 1)
        {
            x = 0;
            y = y + 2;
        }
    }
}

/**
 * @brief OLED 显示中文字符
 *
 * @param x 横坐标，设置列（SEG）起始地址（SEG = x, x=0..127）
 * @param y 纵坐标，设置页（PAGE）起始地址（PAGE = y, y=0..7）
 * @param index 要显示的中文字符在数组 F16X16 中的索引（位于 oledfont.h）
 * @param size 字体大小
 *
 * @note 理想情况下，一个字符占两个 PAGE，一个 PAGE 占 16 个 SEG
 *       字符字体大小 16（字高=字宽=16）
 */
void __OLED_ShowChineseChar(uint8_t x, uint8_t y, uint8_t index, uint8_t size)
{
    uint8_t i = 0;

    /* 如果这一行写不下，就写到下一行（PAGE+2）的开头(SEG=0) */
    if (x > 127 - 16 + 1)
    {
        x = 0;
        y = y + 2;
    }

    if (size == 16)
    {
        /* 先显示上半部分（高 8，宽 16） */
        __OLED_Set_Pos(x, y);
        for (i = 0; i < 16; i++)
            __OLED_Send_Data(F16X16[index * 32 + i]);

        /* 再显示下半部分（PAGE+1，高 8，宽 16） */
        __OLED_Set_Pos(x, y + 1);
        for (i = 0; i < 16; i++)
            __OLED_Send_Data(F16X16[index * 32 + i + 16]);
    }
}

/**
 * @brief OLED 显示（一串）数字
 *
 * @param x 横坐标，设置列（SEG）起始地址（SEG = x, x=0..127）
 * @param y 纵坐标，设置页（PAGE）起始地址（PAGE = y, y=0..7）
 * @param num 要显示的数字（可以是负数）
 * @param size 字体大小
 *
 * @see __OLED_ShowStr()
 */
void __OLED_ShowNum(uint8_t x, uint8_t y, int num, uint8_t size)
{
    /* stm32 的 int 为 32 位，范围：-2147483648 ~ 2147483647 */
    char str[12]; // 12 刚好够长

    /* 数字转字符串 */
    __OLED_Int2Str(num, str);

    /* 调用 __OLED_ShowStr() 显示字符串 */
    __OLED_ShowStr(x, y, str, size);
}

/**
 * @brief 字符串转数字（int to char* ）
 *
 * @param num 要转换的数字
 * @param str 转换得到的字符串
 */
void __OLED_Int2Str(int num, char *str)
{
    /* 0 和 -2147483648(INT32_MIN) 做特殊处理 */
    if (num == 0)
    {
        str[0] = '0';
        str[1] = '\0';
    }
    else if (num == INT32_MIN) // 直接写 -2147483648 会有警告，因为语法检查是先看数字再看负号，2147483648 会被看作 long long
    {
        /* 没想到什么好办法，调库可能更慢，干脆直接一个个往里写 */
        str[0] = '-';
        str[1] = '2';
        str[2] = '1';
        str[3] = '4';
        str[4] = '7';
        str[5] = '4';
        str[6] = '8';
        str[7] = '3';
        str[8] = '6';
        str[9] = '4';
        str[10] = '8';
        str[11] = '\0';
    }
    else /* 数字转字符串 */
    {
        uint8_t length = 0;
        uint8_t left = 0;
        uint8_t right = 0;
        char temp;

        /* 负数转正，字符串首字符为 '-' */
        if (num < 0)
        {
            str[length++] = '-';
            num = -num;
            left = 1; // 反转的时候排除负号
        }

        /* 倒序写入字符串 */
        while (num)
        {
            str[length++] = num % 10 + '0';
            num /= 10;
        }

        /* 末尾加 '\0' */
        str[length] = '\0';

        right = length - 1; // left 默认是 0，负数的话就是 1
        /* 字符串反转（'-' 和 '\0' 在左右边界外） */
        while (left < right)
        {
            temp = str[left];
            str[left] = str[right];
            str[right] = temp;
            left++;
            right--;
        }
    }
}

/**
 * @brief 显示一个字符（ASCII，字高 16，字宽 8）
 *
 * @param row 显示在第几行（0~3）
 * @param col 显示在第几列（0~15）
 * @param ch 要显示的字符
 */
void OLED_ShowChar(uint8_t row, uint8_t col, char ch)
{
    __OLED_ShowChar(col * 8, row * 2, ch, 16);
}

/**
 * @brief 显示一个字符串（ASCII，字高 16，字宽 8）
 *
 * @param row 从第几行开始显示（0~3）
 * @param col 从第几列开始显示（0~15）
 * @param str 指向要显示的字符串的指针
 *
 * @note 太长了会换行，每行最多显示 16 个字符
 */
void OLED_ShowStr(uint8_t row, uint8_t col, char *str)
{
    __OLED_ShowStr(col * 8, row * 2, str, 16);
}

/**
 * @brief 显示一个数字（字高 16，字宽 8）
 *
 * @param row 显示在第几行（0~3）
 * @param col 显示在第几列（0~15）
 * @param num 要显示的数字
 *
 * @note 太长了会换行，每行最多显示 16 个数字
 */
void OLED_ShowNum(uint8_t row, uint8_t col, int num)
{
    __OLED_ShowNum(col * 8, row * 2, num, 16);
}

/**
 * @brief 显示一个中文字符（字高 16，字宽 16）
 * @note 准确的说其实是全宽字符，具体输出什么取决于数组 F16X16
 *
 * @param row 从第几行开始显示（0~3）
 * @param col 从第几列开始显示（0~7）
 * @param index 要显示的中文字符的索引（在 oledfont.h 的 数组 F16X16 里）
 */
void OLED_ShowChineseChar(uint8_t row, uint8_t col, uint8_t index)
{
    __OLED_ShowChineseChar(col * 16, row * 2, index, 16);
}

/* TODO
 *
 * 1. 可以显示前导 0 的 ShowNum 函数
 *    OLED_ShowNum_With_Leading_Zero(uint8_t row, uint8_t col, int num, uint8_t length)
 *
 * 2. 可以显示小数点的 ShowNum 函数
 *    OLED_ShowNum_With_Dot(uint8_t row, uint8_t col, float num)
 */
